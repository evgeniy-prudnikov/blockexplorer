{"ast":null,"code":"\"use strict\";\n\n/* Browser Crypto Shims */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomBytes = exports.pbkdf2Sync = exports.createHmac = exports.createHash = void 0;\nconst hmac_1 = require(\"@noble/hashes/hmac\");\nconst pbkdf2_1 = require(\"@noble/hashes/pbkdf2\");\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst sha512_1 = require(\"@noble/hashes/sha512\");\nconst index_js_1 = require(\"../utils/index.js\");\nfunction getGlobal() {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  throw new Error('unable to locate global object');\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nfunction createHash(algo) {\n  switch (algo) {\n    case \"sha256\":\n      return sha256_1.sha256.create();\n    case \"sha512\":\n      return sha512_1.sha512.create();\n  }\n  (0, index_js_1.assertArgument)(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\nexports.createHash = createHash;\nfunction createHmac(_algo, key) {\n  const algo = {\n    sha256: sha256_1.sha256,\n    sha512: sha512_1.sha512\n  }[_algo];\n  (0, index_js_1.assertArgument)(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n  return hmac_1.hmac.create(algo, key);\n}\nexports.createHmac = createHmac;\nfunction pbkdf2Sync(password, salt, iterations, keylen, _algo) {\n  const algo = {\n    sha256: sha256_1.sha256,\n    sha512: sha512_1.sha512\n  }[_algo];\n  (0, index_js_1.assertArgument)(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n  return (0, pbkdf2_1.pbkdf2)(algo, password, salt, {\n    c: iterations,\n    dkLen: keylen\n  });\n}\nexports.pbkdf2Sync = pbkdf2Sync;\nfunction randomBytes(length) {\n  (0, index_js_1.assert)(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"randomBytes\"\n  });\n  (0, index_js_1.assertArgument)(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n  const result = new Uint8Array(length);\n  crypto.getRandomValues(result);\n  return result;\n}\nexports.randomBytes = randomBytes;","map":{"version":3,"mappings":";;AAAA;;;;;AAEA;AACA;AACA;AACA;AAEA;AAWA,SAASA,SAASA;EAChB,IAAI,OAAOC,IAAI,KAAK,WAAW,EAAE;IAAE,OAAOA,IAAI;;EAC9C,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IAAE,OAAOA,MAAM;;EAClD,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;IAAE,OAAOA,MAAM;;EAClD,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;AACnD;AAAC;AAED,MAAMC,SAAS,GAAGL,SAAS,EAAE;AAC7B,MAAMM,MAAM,GAAQD,SAAS,CAACC,MAAM,IAAID,SAAS,CAACE,QAAQ;AAQ1D,SAAgBC,UAAUA,CAACC,IAAY;EACnC,QAAQA,IAAI;IACR,KAAK,QAAQ;MAAE,OAAOC,eAAM,CAACC,MAAM,EAAE;IACrC,KAAK,QAAQ;MAAE,OAAOC,eAAM,CAACD,MAAM,EAAE;;EAEzC,6BAAc,EAAC,KAAK,EAAE,gCAAgC,EAAE,WAAW,EAAEF,IAAI,CAAC;AAC9E;AANAI;AAQA,SAAgBC,UAAUA,CAACC,KAAa,EAAEC,GAAe;EACrD,MAAMP,IAAI,GAAI;IAAEQ,MAAM,EAANP,eAAM;IAAEQ,MAAM,EAANN;EAAM,CAAE,CAACG,KAAK,CAAE;EACxC,6BAAc,EAACN,IAAI,IAAI,IAAI,EAAE,wBAAwB,EAAE,WAAW,EAAEM,KAAK,CAAC;EAC1E,OAAOI,WAAI,CAACR,MAAM,CAACF,IAAI,EAAEO,GAAG,CAAC;AACjC;AAJAH;AAMA,SAAgBO,UAAUA,CAACC,QAAoB,EAAEC,IAAgB,EAAEC,UAAkB,EAAEC,MAAc,EAAET,KAA0B;EAC7H,MAAMN,IAAI,GAAI;IAAEQ,MAAM,EAANP,eAAM;IAAEQ,MAAM,EAANN;EAAM,CAAE,CAACG,KAAK,CAAE;EACxC,6BAAc,EAACN,IAAI,IAAI,IAAI,EAAE,0BAA0B,EAAE,WAAW,EAAEM,KAAK,CAAC;EAC5E,OAAO,mBAAM,EAACN,IAAI,EAAEY,QAAQ,EAAEC,IAAI,EAAE;IAAEG,CAAC,EAAEF,UAAU;IAAEG,KAAK,EAAEF;EAAM,CAAE,CAAC;AACzE;AAJAX;AAMA,SAAgBc,WAAWA,CAACC,MAAc;EACtC,qBAAM,EAACtB,MAAM,IAAI,IAAI,EAAE,iDAAiD,EAAE,uBAAuB,EAAE;IAC/FuB,SAAS,EAAE;GAAe,CAAC;EAE/B,6BAAc,EAACC,MAAM,CAACC,SAAS,CAACH,MAAM,CAAC,IAAIA,MAAM,GAAG,CAAC,IAAIA,MAAM,IAAI,IAAI,EAAE,gBAAgB,EAAE,QAAQ,EAAEA,MAAM,CAAC;EAE5G,MAAMI,MAAM,GAAG,IAAIC,UAAU,CAACL,MAAM,CAAC;EACrCtB,MAAM,CAAC4B,eAAe,CAACF,MAAM,CAAC;EAC9B,OAAOA,MAAM;AACjB;AATAnB","names":["getGlobal","self","window","global","Error","anyGlobal","crypto","msCrypto","createHash","algo","sha256_1","create","sha512_1","exports","createHmac","_algo","key","sha256","sha512","hmac_1","pbkdf2Sync","password","salt","iterations","keylen","c","dkLen","randomBytes","length","operation","Number","isInteger","result","Uint8Array","getRandomValues"],"sources":["D:\\Alchemy\\blockexplorer\\node_modules\\ethers\\src.ts\\crypto\\crypto-browser.ts"],"sourcesContent":["/* Browser Crypto Shims */\n\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { pbkdf2 } from \"@noble/hashes/pbkdf2\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { sha512 } from \"@noble/hashes/sha512\";\n\nimport { assert, assertArgument } from \"../utils/index.js\";\n\n\ndeclare global {\n    interface Window { }\n\n    const window: Window;\n    const self: Window;\n}\n\n\nfunction getGlobal(): any {\n  if (typeof self !== 'undefined') { return self; }\n  if (typeof window !== 'undefined') { return window; }\n  if (typeof global !== 'undefined') { return global; }\n  throw new Error('unable to locate global object');\n};\n\nconst anyGlobal = getGlobal();\nconst crypto: any = anyGlobal.crypto || anyGlobal.msCrypto;\n\n\nexport interface CryptoHasher {\n    update(data: Uint8Array): CryptoHasher;\n    digest(): Uint8Array;\n}\n\nexport function createHash(algo: string): CryptoHasher {\n    switch (algo) {\n        case \"sha256\": return sha256.create();\n        case \"sha512\": return sha512.create();\n    }\n    assertArgument(false, \"invalid hashing algorithm name\", \"algorithm\", algo);\n}\n\nexport function createHmac(_algo: string, key: Uint8Array): CryptoHasher {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid hmac algorithm\", \"algorithm\", _algo);\n    return hmac.create(algo, key);\n}\n\nexport function pbkdf2Sync(password: Uint8Array, salt: Uint8Array, iterations: number, keylen: number, _algo: \"sha256\" | \"sha512\"): Uint8Array {\n    const algo = ({ sha256, sha512 }[_algo]);\n    assertArgument(algo != null, \"invalid pbkdf2 algorithm\", \"algorithm\", _algo);\n    return pbkdf2(algo, password, salt, { c: iterations, dkLen: keylen });\n}\n\nexport function randomBytes(length: number): Uint8Array {\n    assert(crypto != null, \"platform does not support secure random numbers\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"randomBytes\" });\n\n    assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, \"invalid length\", \"length\", length);\n\n    const result = new Uint8Array(length);\n    crypto.getRandomValues(result);\n    return result;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}