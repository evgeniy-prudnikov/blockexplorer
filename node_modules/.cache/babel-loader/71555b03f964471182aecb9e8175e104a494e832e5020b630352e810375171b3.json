{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.PollingBlockTagSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nfunction getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if ((0, index_js_1.isHexString)(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  (0, index_js_1.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\nexports.getPollingSubscriber = getPollingSubscriber;\n// @TODO: refactor this\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingBlockSubscriber {\n  #provider;\n  #poller;\n  #interval;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  /**\n   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#poller = null;\n    this.#interval = 4000;\n    this.#blockNumber = -2;\n  }\n  /**\n   *  The polling interval.\n   */\n  get pollingInterval() {\n    return this.#interval;\n  }\n  set pollingInterval(value) {\n    this.#interval = value;\n  }\n  async #poll() {\n    try {\n      const blockNumber = await this.#provider.getBlockNumber();\n      // Bootstrap poll to setup our initial block number\n      if (this.#blockNumber === -2) {\n        this.#blockNumber = blockNumber;\n        return;\n      }\n      // @TODO: Put a cap on the maximum number of events per loop?\n      if (blockNumber !== this.#blockNumber) {\n        for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n          // We have been stopped\n          if (this.#poller == null) {\n            return;\n          }\n          await this.#provider.emit(\"block\", b);\n        }\n        this.#blockNumber = blockNumber;\n      }\n    } catch (error) {\n      // @TODO: Minor bump, add an \"error\" event to let subscribers\n      //        know things went awry.\n      //console.log(error);\n    }\n    // We have been stopped\n    if (this.#poller == null) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n  }\n  start() {\n    if (this.#poller) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    this.#poll();\n  }\n  stop() {\n    if (!this.#poller) {\n      return;\n    }\n    this.#provider._clearTimeout(this.#poller);\n    this.#poller = null;\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.PollingBlockSubscriber = PollingBlockSubscriber;\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass OnBlockSubscriber {\n  #provider;\n  #poll;\n  #running;\n  /**\n   *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#running = false;\n    this.#poll = blockNumber => {\n      this._poll(blockNumber, this.#provider);\n    };\n  }\n  /**\n   *  Called on every new block.\n   */\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    this.#poll(-2);\n    this.#provider.on(\"block\", this.#poll);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poll);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.OnBlockSubscriber = OnBlockSubscriber;\nclass PollingBlockTagSubscriber extends OnBlockSubscriber {\n  #tag;\n  #lastBlock;\n  constructor(provider, tag) {\n    super(provider);\n    this.#tag = tag;\n    this.#lastBlock = -2;\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      this.#lastBlock = -2;\n    }\n    super.pause(dropWhilePaused);\n  }\n  async _poll(blockNumber, provider) {\n    const block = await provider.getBlock(this.#tag);\n    if (block == null) {\n      return;\n    }\n    if (this.#lastBlock === -2) {\n      this.#lastBlock = block.number;\n    } else if (block.number > this.#lastBlock) {\n      provider.emit(this.#tag, block.number);\n      this.#lastBlock = block.number;\n    }\n  }\n}\nexports.PollingBlockTagSubscriber = PollingBlockTagSubscriber;\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\n  #filter;\n  constructor(provider, filter) {\n    super(provider);\n    this.#filter = copy(filter);\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(this.#filter);\n  }\n}\nexports.PollingOrphanSubscriber = PollingOrphanSubscriber;\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\n  #hash;\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%hash%%.\n   */\n  constructor(provider, hash) {\n    super(provider);\n    this.#hash = hash;\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(this.#hash);\n    if (tx) {\n      provider.emit(this.#hash, tx);\n    }\n  }\n}\nexports.PollingTransactionSubscriber = PollingTransactionSubscriber;\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingEventSubscriber {\n  #provider;\n  #filter;\n  #poller;\n  #running;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  /**\n   *  Create a new **PollingTransactionSubscriber** attached to\n   *  %%provider%%, listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    this.#provider = provider;\n    this.#filter = copy(filter);\n    this.#poller = this.#poll.bind(this);\n    this.#running = false;\n    this.#blockNumber = -2;\n  }\n  async #poll(blockNumber) {\n    // The initial block hasn't been determined yet\n    if (this.#blockNumber === -2) {\n      return;\n    }\n    const filter = copy(this.#filter);\n    filter.fromBlock = this.#blockNumber + 1;\n    filter.toBlock = blockNumber;\n    const logs = await this.#provider.getLogs(filter);\n    // No logs could just mean the node has not indexed them yet,\n    // so we keep a sliding window of 60 blocks to keep scanning\n    if (logs.length === 0) {\n      if (this.#blockNumber < blockNumber - 60) {\n        this.#blockNumber = blockNumber - 60;\n      }\n      return;\n    }\n    for (const log of logs) {\n      this.#provider.emit(this.#filter, log);\n      // Only advance the block number when logs were found to\n      // account for networks (like BNB and Polygon) which may\n      // sacrifice event consistency for block event speed\n      this.#blockNumber = log.blockNumber;\n    }\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    if (this.#blockNumber === -2) {\n      this.#provider.getBlockNumber().then(blockNumber => {\n        this.#blockNumber = blockNumber;\n      });\n    }\n    this.#provider.on(\"block\", this.#poller);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.PollingEventSubscriber = PollingEventSubscriber;","map":{"version":3,"mappings":"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","names":["copy","obj","JSON","parse","stringify","getPollingSubscriber","provider","event","PollingBlockSubscriber","PollingTransactionSubscriber","operation","info","exports","constructor","pollingInterval","value","#poll","blockNumber","getBlockNumber","b","emit","error","_setTimeout","bind","start","stop","_clearTimeout","pause","dropWhilePaused","resume","OnBlockSubscriber","_poll","Error","on","off","PollingBlockTagSubscriber","tag","block","getBlock","number","PollingOrphanSubscriber","filter","console","log","hash","tx","getTransactionReceipt","PollingEventSubscriber","fromBlock","toBlock","logs","getLogs","length","then"],"sources":["D:\\Alchemy\\blockexplorer\\node_modules\\ethers\\src.ts\\providers\\subscriber-polling.ts"],"sourcesContent":["import { assert, isHexString } from \"../utils/index.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { EventFilter, OrphanFilter, ProviderEvent } from \"./provider.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider: AbstractProvider, event: ProviderEvent): Subscriber {\n    if (event === \"block\") { return new PollingBlockSubscriber(provider); }\n    if (isHexString(event, 32)) { return new PollingTransactionSubscriber(provider, event); }\n\n    assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n\n// @TODO: refactor this\n\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poller: null | number;\n\n    #interval: number;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n\n        this.#blockNumber = -2;\n    }\n\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval(): number { return this.#interval; }\n    set pollingInterval(value: number) { this.#interval = value; }\n\n    async #poll(): Promise<void> {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n\n            // @TODO: Put a cap on the maximum number of events per loop?\n\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) { return; }\n\n                    await this.#provider.emit(\"block\", b);\n                }\n\n                this.#blockNumber = blockNumber;\n            }\n\n        } catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n\n        // We have been stopped\n        if (this.#poller == null) { return; }\n\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n\n    start(): void {\n        if (this.#poller) { return; }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n\n    stop(): void {\n        if (!this.#poller) { return; }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n\n\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poll: (b: number) => void;\n    #running: boolean;\n\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber: number) => {\n            this._poll(blockNumber, this.#provider);\n        }\n    }\n\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poll);\n    }\n\n    pause(dropWhilePaused?: boolean): void { this.stop(); }\n    resume(): void { this.start(); }\n}\n\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n    readonly #tag: string;\n    #lastBlock: number;\n\n    constructor(provider: AbstractProvider, tag: string) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        if (dropWhilePaused) { this.#lastBlock = -2; }\n        super.pause(dropWhilePaused);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) { return; }\n\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        } else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n\n\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter: OrphanFilter;\n\n    constructor(provider: AbstractProvider, filter: OrphanFilter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash: string;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider: AbstractProvider, hash: string) {\n        super(provider);\n        this.#hash = hash;\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) { provider.emit(this.#hash, tx); }\n    }\n}\n\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #filter: EventFilter;\n    #poller: (b: number) => void;\n\n    #running: boolean;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider: AbstractProvider, filter: EventFilter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) { return; }\n\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n\n        const logs = await this.#provider.getLogs(filter);\n\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}