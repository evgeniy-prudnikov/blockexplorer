{"ast":null,"code":"import { isError } from \"../utils/index.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber {\n  #provider;\n  #filterIdPromise;\n  #poller;\n  #running;\n  #network;\n  #hault;\n  /**\n   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n   *  and [[_emitResults]] to setup the subscription and provide the event\n   *  to the %%provider%%.\n   */\n  constructor(provider) {\n    this.#provider = provider;\n    this.#filterIdPromise = null;\n    this.#poller = this.#poll.bind(this);\n    this.#running = false;\n    this.#network = null;\n    this.#hault = false;\n  }\n  /**\n   *  Sub-classes **must** override this to begin the subscription.\n   */\n  _subscribe(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle the events.\n   */\n  _emitResults(provider, result) {\n    throw new Error(\"subclasses must override this\");\n  }\n  /**\n   *  Sub-classes **must** override this handle recovery on errors.\n   */\n  _recover(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  async #poll(blockNumber) {\n    try {\n      // Subscribe if necessary\n      if (this.#filterIdPromise == null) {\n        this.#filterIdPromise = this._subscribe(this.#provider);\n      }\n      // Get the Filter ID\n      let filterId = null;\n      try {\n        filterId = await this.#filterIdPromise;\n      } catch (error) {\n        if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n          throw error;\n        }\n      }\n      // The backend does not support Filter ID; downgrade to\n      // polling\n      if (filterId == null) {\n        this.#filterIdPromise = null;\n        this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n        return;\n      }\n      const network = await this.#provider.getNetwork();\n      if (!this.#network) {\n        this.#network = network;\n      }\n      if (this.#network.chainId !== network.chainId) {\n        throw new Error(\"chaid changed\");\n      }\n      if (this.#hault) {\n        return;\n      }\n      const result = await this.#provider.send(\"eth_getFilterChanges\", [filterId]);\n      await this._emitResults(this.#provider, result);\n    } catch (error) {\n      console.log(\"@TODO\", error);\n    }\n    this.#provider.once(\"block\", this.#poller);\n  }\n  #teardown() {\n    const filterIdPromise = this.#filterIdPromise;\n    if (filterIdPromise) {\n      this.#filterIdPromise = null;\n      filterIdPromise.then(filterId => {\n        this.#provider.send(\"eth_uninstallFilter\", [filterId]);\n      });\n    }\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    this.#poll(-2);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#hault = true;\n    this.#teardown();\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      this.#teardown();\n    }\n    this.#provider.off(\"block\", this.#poller);\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n  #event;\n  /**\n   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n   *  listening for %%filter%%.\n   */\n  constructor(provider, filter) {\n    super(provider);\n    this.#event = copy(filter);\n  }\n  _recover(provider) {\n    return new PollingEventSubscriber(provider, this.#event);\n  }\n  async _subscribe(provider) {\n    const filterId = await provider.send(\"eth_newFilter\", [this.#event]);\n    return filterId;\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(this.#event, provider._wrapLog(result, provider._network));\n    }\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n  async _subscribe(provider) {\n    return await provider.send(\"eth_newPendingTransactionFilter\", []);\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(\"pending\", result);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["isError","PollingEventSubscriber","copy","obj","JSON","parse","stringify","FilterIdSubscriber","constructor","provider","bind","_subscribe","Error","_emitResults","result","_recover","#poll","blockNumber","filterId","error","operation","_recoverSubscriber","network","getNetwork","chainId","send","console","log","once","#teardown","filterIdPromise","then","start","stop","off","pause","dropWhilePaused","resume","FilterIdEventSubscriber","filter","results","emit","_wrapLog","_network","FilterIdPendingSubscriber"],"sources":["D:\\Alchemy\\blockexplorer\\node_modules\\ethers\\src.ts\\providers\\subscriber-filterid.ts"],"sourcesContent":["import { isError } from \"../utils/index.js\";\n\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { Network } from \"./network.js\";\nimport type { EventFilter } from \"./provider.js\";\nimport type { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber implements Subscriber {\n    #provider: JsonRpcApiProvider;\n\n    #filterIdPromise: null | Promise<string>;\n    #poller: (b: number) => Promise<void>;\n\n    #running: boolean;\n\n    #network: null | Network;\n\n    #hault: boolean;\n\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */\n    constructor(provider: JsonRpcApiProvider) {\n        this.#provider = provider;\n\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n\n        this.#running = false;\n\n        this.#network = null;\n\n        this.#hault = false;\n    }\n\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */\n    _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */\n    _emitResults(provider: AbstractProvider, result: Array<any>): Promise<void> {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */\n    _recover(provider: AbstractProvider): Subscriber {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n\n            // Get the Filter ID\n            let filterId: null | string = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            } catch (error) {\n                if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) { this.#network = network; }\n\n            if ((this.#network as Network).chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n\n            if (this.#hault) { return; }\n\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [ filterId ]);\n            await this._emitResults(this.#provider, result);\n        } catch (error) { console.log(\"@TODO\", error); }\n\n        this.#provider.once(\"block\", this.#poller);\n    }\n\n    #teardown(): void {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId) => {\n                this.#provider.send(\"eth_uninstallFilter\", [ filterId ]);\n            });\n        }\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        this.#poll(-2);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        if (dropWhilePaused){ this.#teardown(); }\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    resume(): void { this.start(); }\n}\n\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event: EventFilter;\n\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */\n    constructor(provider: JsonRpcApiProvider, filter: EventFilter) {\n        super(provider);\n        this.#event = copy(filter);\n    }\n\n    _recover(provider: AbstractProvider): Subscriber {\n        return new PollingEventSubscriber(provider, this.#event);\n    }\n\n    async _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        const filterId = await provider.send(\"eth_newFilter\", [ this.#event ]);\n        return filterId;\n    }\n\n    async _emitResults(provider: JsonRpcApiProvider, results: Array<any>): Promise<void> {\n        for (const result of results) {\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        return await provider.send(\"eth_newPendingTransactionFilter\", [ ]);\n    }\n\n    async _emitResults(provider: JsonRpcApiProvider, results: Array<any>): Promise<void> {\n        for (const result of results) {\n            provider.emit(\"pending\", result);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}