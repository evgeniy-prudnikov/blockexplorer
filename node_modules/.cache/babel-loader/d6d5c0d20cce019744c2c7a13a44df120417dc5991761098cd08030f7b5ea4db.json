{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst _u64_js_1 = require(\"./_u64.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = /* @__PURE__ */BigInt(0);\nconst _1n = /* @__PURE__ */BigInt(1);\nconst _2n = /* @__PURE__ */BigInt(2);\nconst _7n = /* @__PURE__ */BigInt(7);\nconst _256n = /* @__PURE__ */BigInt(256);\nconst _0x71n = /* @__PURE__ */BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n    if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */BigInt(j)) - _1n;\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */(0, _u64_js_1.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);\nconst rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s) {\n  let rounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\nexports.keccakP = keccakP;\nclass Keccak extends utils_js_1.Hash {\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(blockLen, suffix, outputLen) {\n    let enableXOF = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let rounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;\n    super();\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    this.pos = 0;\n    this.posOut = 0;\n    this.finished = false;\n    this.destroyed = false;\n    // Can be passed from user as dkLen\n    (0, _assert_js_1.number)(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = (0, utils_js_1.u32)(this.state);\n  }\n  keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data) {\n    (0, _assert_js_1.exists)(this);\n    const {\n      blockLen,\n      state\n    } = this;\n    data = (0, utils_js_1.toBytes)(data);\n    const len = data.length;\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const {\n      state,\n      suffix,\n      pos,\n      blockLen\n    } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  writeInto(out) {\n    (0, _assert_js_1.exists)(this, false);\n    (0, _assert_js_1.bytes)(out);\n    this.finish();\n    const bufferOut = this.state;\n    const {\n      blockLen\n    } = this;\n    for (let pos = 0, len = out.length; pos < len;) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out) {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes) {\n    (0, _assert_js_1.number)(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out) {\n    (0, _assert_js_1.output)(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to) {\n    const {\n      blockLen,\n      suffix,\n      outputLen,\n      rounds,\n      enableXOF\n    } = this;\n    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nexports.sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexports.sha3_256 = gen(0x06, 136, 256 / 8);\nexports.sha3_384 = gen(0x06, 104, 384 / 8);\nexports.sha3_512 = gen(0x06, 72, 512 / 8);\nexports.keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexports.keccak_256 = gen(0x01, 136, 256 / 8);\nexports.keccak_384 = gen(0x01, 104, 384 / 8);\nexports.keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)(function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true);\n});\nexports.shake128 = genShake(0x1f, 168, 128 / 8);\nexports.shake256 = genShake(0x1f, 136, 256 / 8);","map":{"version":3,"mappings":"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","names":["SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","BigInt","_1n","_2n","_7n","_256n","_0x71n","round","R","x","y","push","t","j","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","h","l","s","rotlL","keccakP","rounds","B","Uint32Array","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","fill","exports","Keccak","utils_js_1","constructor","blockLen","suffix","outputLen","enableXOF","Error","state","Uint8Array","state32","keccak","posOut","pos","update","data","len","length","take","Math","min","i","finish","finished","writeInto","out","bufferOut","set","subarray","xofInto","xof","bytes","digestInto","destroy","digest","destroyed","_cloneInto","to","gen","genShake","opts","dkLen","undefined"],"sources":["D:\\Alchemy\\blockexplorer\\node_modules\\@noble\\hashes\\src\\sha3.ts"],"sourcesContent":["import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    exists(this, false);\n    bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}