{"ast":null,"code":"import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data) {\n    exists(this);\n    const {\n      view,\n      buffer,\n      blockLen\n    } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const {\n      buffer,\n      view,\n      blockLen,\n      isLE\n    } = this;\n    let {\n      pos\n    } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const {\n      blockLen,\n      buffer,\n      length,\n      finished,\n      destroyed,\n      pos\n    } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAM,EAAEC,MAAM,QAAQ,cAAc;AAC7C,SAASC,IAAI,EAAEC,UAAU,EAASC,OAAO,QAAQ,YAAY;AAE7D;AACA,SAASC,YAAYA,CAACC,IAAc,EAAEC,UAAkB,EAAEC,KAAa,EAAEC,IAAa;EACpF,IAAI,OAAOH,IAAI,CAACD,YAAY,KAAK,UAAU,EAAE,OAAOC,IAAI,CAACD,YAAY,CAACE,UAAU,EAAEC,KAAK,EAAEC,IAAI,CAAC;EAC9F,MAAMC,IAAI,GAAGC,MAAM,CAAC,EAAE,CAAC;EACvB,MAAMC,QAAQ,GAAGD,MAAM,CAAC,UAAU,CAAC;EACnC,MAAME,EAAE,GAAGC,MAAM,CAAEN,KAAK,IAAIE,IAAI,GAAIE,QAAQ,CAAC;EAC7C,MAAMG,EAAE,GAAGD,MAAM,CAACN,KAAK,GAAGI,QAAQ,CAAC;EACnC,MAAMI,CAAC,GAAGP,IAAI,GAAG,CAAC,GAAG,CAAC;EACtB,MAAMQ,CAAC,GAAGR,IAAI,GAAG,CAAC,GAAG,CAAC;EACtBH,IAAI,CAACY,SAAS,CAACX,UAAU,GAAGS,CAAC,EAAEH,EAAE,EAAEJ,IAAI,CAAC;EACxCH,IAAI,CAACY,SAAS,CAACX,UAAU,GAAGU,CAAC,EAAEF,EAAE,EAAEN,IAAI,CAAC;AAC1C;AAEA;AACA,OAAM,MAAgBU,IAAwB,SAAQjB,IAAO;EAc3DkB,YACWC,QAAgB,EAClBC,SAAiB,EACfC,SAAiB,EACjBd,IAAa;IAEtB,KAAK,EAAE;IALE,aAAQ,GAARY,QAAQ;IACV,cAAS,GAATC,SAAS;IACP,cAAS,GAATC,SAAS;IACT,SAAI,GAAJd,IAAI;IATL,aAAQ,GAAG,KAAK;IAChB,WAAM,GAAG,CAAC;IACV,QAAG,GAAG,CAAC;IACP,cAAS,GAAG,KAAK;IASzB,IAAI,CAACe,MAAM,GAAG,IAAIC,UAAU,CAACJ,QAAQ,CAAC;IACtC,IAAI,CAACf,IAAI,GAAGH,UAAU,CAAC,IAAI,CAACqB,MAAM,CAAC;EACrC;EACAE,MAAMA,CAACC,IAAW;IAChB3B,MAAM,CAAC,IAAI,CAAC;IACZ,MAAM;MAAEM,IAAI;MAAEkB,MAAM;MAAEH;IAAQ,CAAE,GAAG,IAAI;IACvCM,IAAI,GAAGvB,OAAO,CAACuB,IAAI,CAAC;IACpB,MAAMC,GAAG,GAAGD,IAAI,CAACE,MAAM;IACvB,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGF,GAAG,GAAI;MAC7B,MAAMG,IAAI,GAAGC,IAAI,CAACC,GAAG,CAACZ,QAAQ,GAAG,IAAI,CAACS,GAAG,EAAEF,GAAG,GAAGE,GAAG,CAAC;MACrD;MACA,IAAIC,IAAI,KAAKV,QAAQ,EAAE;QACrB,MAAMa,QAAQ,GAAG/B,UAAU,CAACwB,IAAI,CAAC;QACjC,OAAON,QAAQ,IAAIO,GAAG,GAAGE,GAAG,EAAEA,GAAG,IAAIT,QAAQ,EAAE,IAAI,CAACc,OAAO,CAACD,QAAQ,EAAEJ,GAAG,CAAC;QAC1E;;MAEFN,MAAM,CAACY,GAAG,CAACT,IAAI,CAACU,QAAQ,CAACP,GAAG,EAAEA,GAAG,GAAGC,IAAI,CAAC,EAAE,IAAI,CAACD,GAAG,CAAC;MACpD,IAAI,CAACA,GAAG,IAAIC,IAAI;MAChBD,GAAG,IAAIC,IAAI;MACX,IAAI,IAAI,CAACD,GAAG,KAAKT,QAAQ,EAAE;QACzB,IAAI,CAACc,OAAO,CAAC7B,IAAI,EAAE,CAAC,CAAC;QACrB,IAAI,CAACwB,GAAG,GAAG,CAAC;;;IAGhB,IAAI,CAACD,MAAM,IAAIF,IAAI,CAACE,MAAM;IAC1B,IAAI,CAACS,UAAU,EAAE;IACjB,OAAO,IAAI;EACb;EACAC,UAAUA,CAACC,GAAe;IACxBxC,MAAM,CAAC,IAAI,CAAC;IACZC,MAAM,CAACuC,GAAG,EAAE,IAAI,CAAC;IACjB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB;IACA;IACA;IACA,MAAM;MAAEjB,MAAM;MAAElB,IAAI;MAAEe,QAAQ;MAAEZ;IAAI,CAAE,GAAG,IAAI;IAC7C,IAAI;MAAEqB;IAAG,CAAE,GAAG,IAAI;IAClB;IACAN,MAAM,CAACM,GAAG,EAAE,CAAC,GAAG,UAAU;IAC1B,IAAI,CAACN,MAAM,CAACa,QAAQ,CAACP,GAAG,CAAC,CAACY,IAAI,CAAC,CAAC,CAAC;IACjC;IACA,IAAI,IAAI,CAACnB,SAAS,GAAGF,QAAQ,GAAGS,GAAG,EAAE;MACnC,IAAI,CAACK,OAAO,CAAC7B,IAAI,EAAE,CAAC,CAAC;MACrBwB,GAAG,GAAG,CAAC;;IAET;IACA,KAAK,IAAIa,CAAC,GAAGb,GAAG,EAAEa,CAAC,GAAGtB,QAAQ,EAAEsB,CAAC,EAAE,EAAEnB,MAAM,CAACmB,CAAC,CAAC,GAAG,CAAC;IAClD;IACA;IACA;IACAtC,YAAY,CAACC,IAAI,EAAEe,QAAQ,GAAG,CAAC,EAAEV,MAAM,CAAC,IAAI,CAACkB,MAAM,GAAG,CAAC,CAAC,EAAEpB,IAAI,CAAC;IAC/D,IAAI,CAAC0B,OAAO,CAAC7B,IAAI,EAAE,CAAC,CAAC;IACrB,MAAMsC,KAAK,GAAGzC,UAAU,CAACqC,GAAG,CAAC;IAC7B,MAAMZ,GAAG,GAAG,IAAI,CAACN,SAAS;IAC1B;IACA,IAAIM,GAAG,GAAG,CAAC,EAAE,MAAM,IAAIiB,KAAK,CAAC,6CAA6C,CAAC;IAC3E,MAAMC,MAAM,GAAGlB,GAAG,GAAG,CAAC;IACtB,MAAMmB,KAAK,GAAG,IAAI,CAACC,GAAG,EAAE;IACxB,IAAIF,MAAM,GAAGC,KAAK,CAAClB,MAAM,EAAE,MAAM,IAAIgB,KAAK,CAAC,oCAAoC,CAAC;IAChF,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,MAAM,EAAEH,CAAC,EAAE,EAAEC,KAAK,CAAC1B,SAAS,CAAC,CAAC,GAAGyB,CAAC,EAAEI,KAAK,CAACJ,CAAC,CAAC,EAAElC,IAAI,CAAC;EACzE;EACAwC,MAAMA;IACJ,MAAM;MAAEzB,MAAM;MAAEF;IAAS,CAAE,GAAG,IAAI;IAClC,IAAI,CAACiB,UAAU,CAACf,MAAM,CAAC;IACvB,MAAM0B,GAAG,GAAG1B,MAAM,CAAC2B,KAAK,CAAC,CAAC,EAAE7B,SAAS,CAAC;IACtC,IAAI,CAAC8B,OAAO,EAAE;IACd,OAAOF,GAAG;EACZ;EACAG,UAAUA,CAACC,EAAM;IACfA,EAAE,KAAFA,EAAE,GAAK,IAAK,IAAI,CAAClC,WAAmB,EAAO;IAC3CkC,EAAE,CAAClB,GAAG,CAAC,GAAG,IAAI,CAACY,GAAG,EAAE,CAAC;IACrB,MAAM;MAAE3B,QAAQ;MAAEG,MAAM;MAAEK,MAAM;MAAEY,QAAQ;MAAEc,SAAS;MAAEzB;IAAG,CAAE,GAAG,IAAI;IACnEwB,EAAE,CAACzB,MAAM,GAAGA,MAAM;IAClByB,EAAE,CAACxB,GAAG,GAAGA,GAAG;IACZwB,EAAE,CAACb,QAAQ,GAAGA,QAAQ;IACtBa,EAAE,CAACC,SAAS,GAAGA,SAAS;IACxB,IAAI1B,MAAM,GAAGR,QAAQ,EAAEiC,EAAE,CAAC9B,MAAM,CAACY,GAAG,CAACZ,MAAM,CAAC;IAC5C,OAAO8B,EAAE;EACX","names":["exists","output","Hash","createView","toBytes","setBigUint64","view","byteOffset","value","isLE","_32n","BigInt","_u32_max","wh","Number","wl","h","l","setUint32","SHA2","constructor","blockLen","outputLen","padOffset","buffer","Uint8Array","update","data","len","length","pos","take","Math","min","dataView","process","set","subarray","roundClean","digestInto","out","finished","fill","i","oview","Error","outLen","state","get","digest","res","slice","destroy","_cloneInto","to","destroyed"],"sources":["D:\\Alchemy\\blockexplorer\\node_modules\\@noble\\hashes\\src\\_sha2.ts"],"sourcesContent":["import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}